[
    {
      "title": "Fragment",
      "content": "<p>A Fragment represents a behavior or a portion of user interface in a FragmentActivity. Its life cycle is:<br/><br/> <i>onAttach()<br/> onCreate()<br/> onCreateView()<br/> onActivityCreated()<br/> onStart()<br/> onResume()<br/> onPause()<br/> onStop()<br/> onDestroyView()<br/> onDestroy()<br/> onDetach()</i></p>",
      "image_url": "",
      "deck": "Android"
    },
    {
      "title": "Activity",
      "content": "<p>An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(View). While activities are often presented to the user as full-screen windows, they can also be used in other ways: as floating windows (via a theme with R.attr.windowIsFloating set). Its life cycle is:<br/><br/><i>onCreate()<br/>onStart()<br/>onResume()<br/>onPause()<br/>onStop()<br/>onDestroy()<br/></p>",
      "image_url": "",
      "deck": "Android"
    },
    {
      "title": "Manifest.xml file",
      "content": "<p>The manifest file describes essential information about your app to the Android build tools, the Android operating system, and Google Play. It should specify at least:<br/><br/>app package<br/>components (activities, services, etc)<br/>permissions<br/>hardware and software required</p>",
      "image_url": "",
      "deck": "Android"
    },
    {
      "title": "Dalvik",
      "content": "<p>Dalvik is a <b>discontinued</b> process virtual machine (VM) in Google's Android operating system that executes applications written for Android. The generated bytecode uis stored as dex (Dalvik EXecutable) or odex (Optimized Dalvik EXecutable)</p><p>Since Android 4.4 it started to be replaced by Android RunTime (ART)</p>",
      "image_url": "",
      "deck": "Android"
    },
    {
      "title": "Android Device Bridge (ADB)",
      "content": "<p>Android Debug Bridge (adb) is a versatile command-line tool that lets you communicate with a device through a Unix like shell. It includes:</p><p>A <b>client</b> which sends commands from the development machine</p><p>A <b> daemon (abdb)</b> which runs the commands in the device</p><p>A <b>server</b> that manages the communication between the client and the daemon</p>",
      "image_url": "",
      "deck": "Android"
    },

    {
      "title": "Service",
      "content": "<p>A Service is an application component that can perform long-running operations in the background, and it doesn't provide a user interface. IT always runs in background even if the user switches to another application.Its life cycle is the following:<br/><br/><i>onStartCommand()<br/>onBind()<br/>onCreate()<br/>onDestroy()</p>",
      "image_url": "",
      "deck": "Android"
    },
    {
      "title": "Broadcast Receiver",
      "content": "<p>With this component we can register receivers for any system-level or application-level event. Once that event occurs, android system will notify the registered receivers about the execution of events respectively</p><p>There are two types of receivers: <i>Normal and Ordered Broadcasts</i>. Its inline code runs only when the app is running. It has no UI but it can start an Activity and it lives for 10 seconds only so it is not recommended to do hard work in it</p>",
      "image_url": "",
      "deck": "Android"
    },
    {
      "title": "Content Providers",
      "content": "<p>A content provider manages access to a central repository of data. A provider is part of an Android application, which often provides its own UI for working with the data. However, content providers are primarily intended to be used by other applications, which access the provider using a provider client object. Together, providers and provider clients offer a consistent, standard interface to data that also handles inter-process communication and secure data access.</p>",
      "image_url": "",
      "deck": "Android"
    },
    {
      "title": "Intent Types",
      "content": "<p><b>Intent</b> - is a message passing mechanism between components of Android, except for Content Provider. You can use Intent to start any component.</p><p><b>Sticky Intent</b> - Sticks with Android, for future broadcast listeners. For example if BATTERY_LOW event occurs then that Intent will stick with Android so that any future requests for BATTERY_LOW, will return the Intent.</p><p><b>Pending Intent</b> - If you want some one to perform any Intent operation at future point of time on behalf of you, then we will use Pending Intent.</p>",
      "image_url": "",
      "deck": "Android"
    },
    {
      "title": "Normal Broadcast",
      "content": "<p>These are asynchronous broadcasts.</p><p>Receivers of this type of broadcasts may run in any order, sometimes altogether.</p><p>This is efficient.</p><p>Receivers cannot use the result.</p><p>They cannot abort the included APIs.</p><p>These broadcasts are sent with Context.sendBroadcast</p>",
      "image_url": "",
      "deck": "Android"
    },

    {
      "title": "Ordered Broadcast",
      "content": "<p>These are synchronous broadcasts.</p><p>One broadcast is delivered to one receiver at a time.</p><p>Receivers can use the result. In fact as each receiver executes, result is passed to next receiver.</p><p>Receiver can abort the broadcast and hence no broadcast is received by other receivers.</p><p>The order of receivers is managed and controlled by the attribute android:priority in corresponding intent-filter.</p><p>If receivers will have same priority then they may run in any order.</p>",
      "image_url": "",
      "deck": "Android"
    },
    {
      "title": "Data and file storage",
      "content": "<p><b>Internal file storage</b>: Store app-private files on the device file system. <br/><br/><b>External file storage</b>: Store files on the shared external file system. This is usually for shared user files, such as photos.<br/><br/><b>Shared preferences</b>: Store private primitive data in key-value pairs.<br/><br/><b>Databases</b>: Store structured data in a private database</p>",
      "image_url": "",
      "deck": "Android"
    },
    {
      "title": "Limited number of methods &amp; Multidex",
      "content": "<p>The Dalvik Executable specification limits the total number of methods that can be referenced within a single DEX file to 65,536â€”including Android framework methods, library methods, and methods in your own code.</p><p>If the number of methods in your app is bugger than that you should apply multidex in the build.gradle file",
      "image_url": "",
      "deck": "Android"
    },
    {
      "title": "Services, Threads, AsyncTasks, Executor",
      "content": "<p><b>Use Service</b> for tasks with no UI, but shouldn't be too long. Use threads within service for long tasks.</p><p><b>Use thread</b> for long tasks in general</p><p>For tasks in parallel use <b>Multiple threads</b> (traditional mechanisms)</p><p><b>Use AsyncTasks</b> for small task having to communicate with main thread.</p><p>For tasks in parallel use multiple instances of async tasks OR <b>Executor</b></p>",
      "image_url": "",
      "deck": "Android"
    },
    {
      "title": "Difference between FutureTask &amp; AsyncTask",
      "content": "<p><b>AsyncTask</b> provides callbacks (onPreExecute, onProgressExecute, and onPostExecute) which are guaranteed to run on the UI thread</p><p><b>FutureTask</b> provides no callbacks and doesn't know anything about the Android UI thread. In fact, Android apps shouldn't call Future.get() from the UI thread, because it may block.</p>",
      "image_url": "",
      "deck": "Android"
    }
  ]
