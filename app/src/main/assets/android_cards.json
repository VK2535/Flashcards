[
  {
    "title": "Fragment",
    "content": "<p>A Fragment represents a behavior or a portion of user interface in a FragmentActivity. Its life cycle is:<br/><br/> <i>onAttach()<br/> onCreate()<br/> onCreateView()<br/> onActivityCreated()<br/> onStart()<br/> onResume()<br/> onPause()<br/> onStop()<br/> onDestroyView()<br/> onDestroy()<br/> onDetach()</i></p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "ANR",
    "content": "<p>When the UI thread of an Android app is blocked for too long, an \"Application Not Responding\" (ANR) error is triggered. If the app is in the foreground, the system displays a dialog to the user. May be triggered when:<br><br>>While your activity is in the foreground, your app has not responded to an input event or BroadcastReceiver (such as key press or screen touch events) within 5 seconds<br>>While you do not have an activity in the foreground, your BroadcastReceiver hasn't finished executing within a considerable amount of time.</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Activity",
    "content": "<p>A single screen in an application, with supporting Java code, derived from the Activity class. Most commonly, an activity is visibly represented by a full screen window that can receive and handle UI events and perform complex tasks, because of the Window it uses to render its window. Though an Activity is typically full screen, it can also be floating or transparent.. Its life cycle is:<br/><br/><i>onCreate()<br/>onStart()<br/>onResume()<br/>onPause()<br/>onStop()<br/>onDestroy()<br/></p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "common keywords in Retrofit",
    "content": "<p><i>@GET(\"url\")</i>: for GET queries<br><br><i>POST(\"url\") for</i> POST call. Should use @Body(Java class) to work<br><br><i>@FormUrlEncoded</i>: Used in a POST call to indicate the post should be constructed send as part of the URL using @Field for each input parameter<br><br>@Field(\"field_name\")</i>: To indicate the name of a part attribute to send<br><br><i>@url</i>: Used to overwrite the base URL for any call<br><br>@QueryMap/@FieldMap</i>: Used to send URL parameters as a map in a GET/POST respectively</p>",
    "image_url": "",
    "deck": "Kotlin"
  },
  {
    "title": "How to use a RecyclerView.Adapter",
    "content": "<p>1. Create your adapter class implementing RecyclerView.Adapter&lt;T></p><p>2. Create a ViewHolder class</p><p>Implement the method onCreateViewHolder(), getItemCount(), and onBindViewHolder()</p><p>3. Set this adapter in your recycler view",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Manifest.xml file",
    "content": "<p>The manifest file describes essential information about your app to the Android build tools, the Android operating system, and Google Play. It should specify at least:<br/><br/>app package<br/>components (activities, services, etc)<br/>permissions<br/>hardware and software required</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Dalvik",
    "content": "<p>Dalvik is a <b>discontinued</b> process virtual machine (VM) in Google's Android operating system that executes applications written for Android. The generated bytecode uis stored as dex (Dalvik EXecutable) or odex (Optimized Dalvik EXecutable)</p><p>Since Android 4.4 it started to be replaced by Android RunTime (ART)</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Android Device Bridge (ADB)",
    "content": "<p>Android Debug Bridge (adb) is a versatile command-line tool that lets you communicate with a device through a Unix like shell. It includes:</p><p>A <b>client</b> which sends commands from the development machine</p><p>A <b> daemon (abdb)</b> which runs the commands in the device</p><p>A <b>server</b> that manages the communication between the client and the daemon</p>",
    "image_url": "",
    "deck": "Android"
  },

  {
    "title": "Service",
    "content": "<p>A Service is an application component that can perform long-running operations in the background, and it doesn't provide a user interface. IT always runs in background even if the user switches to another application.Its life cycle is the following:<br/><br/><i>onStartCommand()<br/>onBind()<br/>onCreate()<br/>onDestroy()</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Broadcast Receiver",
    "content": "<p>With this component we can register receivers for any system-level or application-level event. Once that event occurs, android system will notify the registered receivers about the execution of events respectively</p><p>There are two types of receivers: <i>Normal and Ordered Broadcasts</i>. Its inline code runs only when the app is running. It has no UI but it can start an Activity and it lives for 10 seconds only so it is not recommended to do hard work in it</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Content Providers",
    "content": "<p>A content provider manages access to a central repository of data. A provider is part of an Android application, which often provides its own UI for working with the data. However, content providers are primarily intended to be used by other applications, which access the provider using a provider client object. Together, providers and provider clients offer a consistent, standard interface to data that also handles inter-process communication and secure data access.</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Intent Types",
    "content": "<p><b>Intent</b> - is a message passing mechanism between components of Android, except for Content Provider. You can use Intent to start any component.</p><p><b>Sticky Intent</b> - Sticks with Android, for future broadcast listeners. For example if BATTERY_LOW event occurs then that Intent will stick with Android so that any future requests for BATTERY_LOW, will return the Intent.</p><p><b>Pending Intent</b> - If you want some one to perform any Intent operation at future point of time on behalf of you, then we will use Pending Intent.</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Normal Broadcast",
    "content": "<p>These are asynchronous broadcasts.</p><p>Receivers of this type of broadcasts may run in any order, sometimes altogether.</p><p>This is efficient.</p><p>Receivers cannot use the result.</p><p>They cannot abort the included APIs.</p><p>These broadcasts are sent with Context.sendBroadcast</p>",
    "image_url": "",
    "deck": "Android"
  },

  {
    "title": "Ordered Broadcast",
    "content": "<p>These are synchronous broadcasts.</p><p>One broadcast is delivered to one receiver at a time.</p><p>Receivers can use the result. In fact as each receiver executes, result is passed to next receiver.</p><p>Receiver can abort the broadcast and hence no broadcast is received by other receivers.</p><p>The order of receivers is managed and controlled by the attribute android:priority in corresponding intent-filter.</p><p>If receivers will have same priority then they may run in any order.</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Data and file storage",
    "content": "<p><b>Internal file storage</b>: Store app-private files on the device file system. <br/><br/><b>External file storage</b>: Store files on the shared external file system. This is usually for shared user files, such as photos.<br/><br/><b>Shared preferences</b>: Store private primitive data in key-value pairs.<br/><br/><b>Databases</b>: Store structured data in a private database</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Limited number of methods &amp; Multidex",
    "content": "<p>The Dalvik Executable specification limits the total number of methods that can be referenced within a single DEX file to 65,536â€”including Android framework methods, library methods, and methods in your own code.</p><p>If the number of methods in your app is bugger than that you should apply multidex in the build.gradle file",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Services, Threads, AsyncTasks, Executor",
    "content": "<p><b>Use Service</b> for tasks with no UI, but shouldn't be too long. Use threads within service for long tasks.</p><p><b>Use thread</b> for long tasks in general</p><p>For tasks in parallel use <b>Multiple threads</b> (traditional mechanisms)</p><p><b>Use AsyncTasks</b> for small task having to communicate with main thread.</p><p>For tasks in parallel use multiple instances of async tasks OR <b>Executor</b></p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Difference between FutureTask &amp; AsyncTask",
    "content": "<p><b>AsyncTask</b> provides callbacks (onPreExecute, onProgressExecute, and onPostExecute) which are guaranteed to run on the UI thread</p><p><b>FutureTask</b> provides no callbacks and doesn't know anything about the Android UI thread. In fact, Android apps shouldn't call Future.get() from the UI thread, because it may block.</p>",
    "image_url": "",
    "deck": "Android"
  },

  {
    "title": ".apk file",
    "content": "<p>Android application package file. Each Android application is compiled and packaged in a single file that includes all of the application's code (.dex files), resources, assets, and manifest file</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": ".dex file",
    "content": "<p>Compiled Android application code file. Android programs are compiled into .dex (Dalvik Executable) files, which are in turn zipped into a single .apk file on the device. .dex files can be created by automatically translating compiled applications written in the Java programming language</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Action",
    "content": "<p>A description of something that an Intent sender wants done. An action is a string value assigned to an Intent. Action strings can be defined by Android or by a third-party developer. For example, android.intent.action.VIEW for a Web URL, or com.example.rumbler.SHAKE_PHONE for a custom application to vibrate the phone</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Android Device Bridge (adb)",
    "content": "<p>Android Debug Bridge, a command-line debugging application included with the SDK. It provides tools to browse the device, copy tools on the device, and forward ports for debugging. If you are developing in Android Studio, adb is integrated into your development environment. See Android Debug Bridge for more information.</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Application",
    "content": "<p>From a component perspective, an Android application consists of one or more activities, services, listeners, and intent receivers. From a source file perspective, an Android application consists of code, resources, assets, and a single manifest. During compilation, these files are packaged in a single file called an application package file (.apk).</p>",
    "image_url": "",
    "deck": "Android"
  },

  {
    "title": "Canvas",
    "content": "<p>A drawing surface that handles compositing of the actual bits against a Bitmap or Surface object. It has methods for standard computer drawing of bitmaps, lines, circles, rectangles, text, and so on, and is bound to a Bitmap or Surface. Canvas is the simplest, easiest way to draw 2D objects on the screen. However, it does not support hardware acceleration, as OpenGL ES does. The base class is Canvas</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Dialog",
    "content": "<p>A floating window that acts as a lightweight form. A dialog can have button controls only and is intended to perform a simple action (such as button choice) and perhaps return a value. A dialog is not intended to persist in the history stack, contain complex layout, or perform complex actions. Android provides a default simple dialog for you with optional buttons, though you can define your own dialog layout. The base class for dialogs is Dialog</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Drawable",
    "content": "<p>A compiled visual resource that can be used as a background, title, or other part of the screen. A drawable is typically loaded into another UI element, for example as a background image. A drawable is not able to receive events, but does assign various other properties such as \"state\" and scheduling, to enable subclasses such as animation objects or image libraries. Many drawable objects are loaded from drawable resource files â€” xml or bitmap files that describe the image. Drawable resources are compiled into subclasses of android.graphics.drawable</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Intent",
    "content": "<p>An message object that you can use to launch or communicate with other applications/activities asynchronously. An Intent object is an instance of Intent. It includes several criteria fields that you can supply, to determine what application/activity receives the Intent and what the receiver does when handling the Intent.</p><p>The Android system is responsible for resolving the best-available receiver for each Intent, based on the criteria supplied in the Intent and the Intent Filters defined by other applications</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Intent Filter",
    "content": "<p>A filter object that an application declares in its manifest file, to tell the system what types of Intents each of its components is willing to accept and with what criteria. Through an intent filter, an application can express interest in specific data types, Intent actions, URI formats, and so on</p>",
    "image_url": "",
    "deck": "Android"
  },

  {
    "title": "Layout Resource",
    "content": "<p>An XML file that describes the layout of an Activity screen.</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Nine-patch / 9-patch / Ninepatch image",
    "content": "<p>A resizeable bitmap resource that can be used for backgrounds or other images on the device. </p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "OpenGL ES",
    "content": "<p>Android provides OpenGL ES libraries that you can use for fast, complex 3D images. It is harder to use than a Canvas object, but better for 3D objects. The android.opengl and javax.microedition.khronos.opengles packages expose OpenGL ES functionality.</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Resources",
    "content": "<p>Non-programmatic application components that are external to the compiled application code, but which can be loaded from application code using a well-known reference format. Android supports a variety of resource types, but a typical application's resources would consist of UI strings, UI layout components, graphics or other media files, and so on. An application uses resources to efficiently support localization and varied device profiles and states</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Surface",
    "content": "<p>An object of type Surface representing a block of memory that gets composited to the screen. A Surface holds a Canvas object for drawing, and provides various helper methods to draw layers and resize the surface. You should not use this class directly; use SurfaceView instead</p>",
    "image_url": "",
    "deck": "Android"
  },

  {
    "title": "SurfaceView",
    "content": "<p>A View object that wraps a Surface for drawing, and exposes methods to specify its size and format dynamically. A SurfaceView provides a way to draw independently of the UI thread for resource-intensive operations (such as games or camera previews), but it uses extra memory as a result. SurfaceView supports both Canvas and OpenGL ES graphics. The base class is SurfaceView</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Theme",
    "content": "<p>A set of properties (text size, background color, and so on) bundled together to define various default display settings. Android provides a few standard themes, listed in R.style (starting with \"Theme_\").</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "URIs in Android",
    "content": "<p>Android uses URI (uniform resource identifier) strings as the basis for requesting data in a content provider (such as to retrieve a list of contacts) and for requesting actions in an Intent (such as opening a Web page in a browser). The URI scheme and format is specialized according to the type of use, and an application can handle specific URI schemes and strings in any way it wants. Some URI schemes are reserved by system components. For example, requests for data from a content provider must use the content://. In an Intent, a URI using an http:// scheme will be handled by the browser.</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "View",
    "content": "<p>An object that draws to a rectangular area on the screen and handles click, keystroke, and other interaction events. A view is a base class for most layout components of an Activity or Dialog screen (text boxes, windows, and so on). It receives calls from its parent object (see ViewGroup) to draw itself, and informs its parent object about where and how big it would like to be (which may or may not be respected by the parent).</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "View Hierarchy",
    "content": "<p>An arrangement of View and ViewGroup objects that defines the user interface for each component of an app. The hierarchy consists of view groups that contain one or more child views or view groups. You can obtain a visual representation of a view hierarchy for debugging and optimization by using the Hierarchy Viewer that is supplied with the Android SDK.</p>",
    "image_url": "",
    "deck": "Android"
  },

  {
    "title": "ViewGroup",
    "content": "<p>A container object that groups a set of child views. The view group is responsible for deciding where child views are positioned and how large they can be, as well as for calling each to draw itself when appropriate. Some view groups are invisible and are for layout only, while others have an intrinsic UI (for instance, a scrolling list box). View groups are all in the widget package, but extend ViewGroup.</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Widget",
    "content": "<p>One of a set of fully implemented View subclasses that render form elements and other UI components, such as a text box or popup menu. Because a widget is fully implemented, it handles measuring and drawing itself and responding to screen events. Widgets are all in the android.widget package</p>",
    "image_url": "",
    "deck": "Android"
  },
  {
    "title": "Window",
    "content": "<p>In an Android application, an object derived from the abstract class Window that specifies the elements of a generic window, such as the look and feel (title bar text, location and content of menus, and so on). Dialog and Activity use an implementation of this class to render a window. You do not need to implement this class or use windows in your application</p>",
    "image_url": "",
    "deck": "Android"
  }

]
